/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.3
	(function() {
	  var anim, root;

	  root = void 0;

	  anim = void 0;

	  DirectPano.show_pano = function() {
	    var i, image, panos_list;
	    image = $("<img id='start-image'/>");
	    image.css({
	      'visibility': 'visible',
	      'height': Math.min(DirectPano.initial_height, window.innerHeight) + 'px',
	      'width': Math.min(DirectPano.initial_width, window.innerWidth) + 'px',
	      'z-index': '1',
	      'position': 'absolute',
	      'left': '0px',
	      'top': '0px'
	    });
	    image.attr("src", "./Dataset/panos-house/start.jpg");
	    $("#" + DirectPano.pano_div_id).append(image);
	    $("#panos-list").remove();
	    $("#" + DirectPano.pano_div_id).append("<div id='panos-list'></div>");
	    panos_list = $("#panos-list");
	    i = 0;
	    while (i < DirectPano.pano.length) {
	      if (DirectPano.pano[i][2] === true) {
	        panos_list.append("<div id='panos-list-entry-" + i + "'>" + DirectPano.pano[i][0] + "</div>");
	        $("#panos-list-entry-" + i).attr('pano_id', parseInt(i));
	        $("#panos-list-entry-" + i).bind('click touchstart', function() {
	          if (root.Transition.moving === false) {
	            root.Transition.start(null, parseInt(this.getAttribute('pano_id')));
	          }
	        });
	      }
	      i++;
	    }
	    root = __webpack_require__(1);
	    root.Annotation = new root.annotation(DirectPano.annotation_angles);
	    root.Annotation.add_annotations(0);
	    root.scene.children.length = 0;
	    root.add_listeners();
	    root.Hotspot = new root.hotspot(DirectPano.hotspots_angle);
	    root.Transition = new root.transition(DirectPano.pano, DirectPano.hotspots_angle);
	    root.Hotspot.add_hotspots(0);
	    anim = new root.animation();
	    root.Config.isUserInteracting = true;
	  };

	  DirectPano.remove_pano = function() {
	    anim.destroy = true;
	    anim = null;
	    root.remove_listeners();
	    root.Hotspot.destroy_hotspot();
	    root.Hotspot = null;
	    root.Transition.destroy_transition();
	    root.Transition = null;
	    root.Annotation.destroy_annotation();
	    root.Annotation = null;
	    root.destroy();
	  };

	}).call(this);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.3
	(function() {
	  var add_listeners, onPointerDownLat, onPointerDownLon, onPointerDownPointerX, onPointerDownPointerY, on_key_down, on_key_up, on_mouse_down, on_mouse_move, on_mouse_up, on_mouse_wheel, remove_listeners, root, touch_handler;

	  root = __webpack_require__(2);

	  onPointerDownPointerX = void 0;

	  onPointerDownPointerY = void 0;

	  onPointerDownLon = void 0;

	  onPointerDownLat = void 0;

	  touch_handler = function(event) {
	    var first, simulatedEvent, touches, type;
	    touches = event.changedTouches;
	    first = touches[0];
	    type = '';
	    switch (event.type) {
	      case 'touchstart':
	        type = 'mousedown';
	        break;
	      case 'touchmove':
	        type = 'mousemove';
	        break;
	      case 'touchend':
	        type = 'mouseup';
	        break;
	      default:
	        return;
	    }
	    simulatedEvent = document.createEvent('MouseEvent');
	    simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0, null);
	    first.target.dispatchEvent(simulatedEvent);
	    event.preventDefault();
	  };

	  on_mouse_down = function(event) {
	    var container, intersects, vector;
	    event.preventDefault();
	    root.Config.current_lon = root.Config.lon;
	    root.Config.target_lon = root.Config.lon;
	    root.Config.current_lat = root.Config.lat;
	    root.Config.target_lat = root.Config.lat;
	    root.Config.isUserInteracting = true;
	    onPointerDownPointerX = event.clientX;
	    onPointerDownPointerY = event.clientY;
	    onPointerDownLon = root.Config.lon;
	    onPointerDownLat = root.Config.lat;
	    vector = new THREE.Vector3;
	    container = $("#" + DirectPano.pano_div_id);
	    vector.set(event.clientX / container.outerWidth() * 2 - 1, -(event.clientY / container.outerHeight()) * 2 + 1, 0.5);
	    vector.unproject(root.camera);
	    root.raycaster.set(root.camera.position, vector.sub(root.camera.position).normalize());
	    intersects = root.raycaster.intersectObjects(root.scene.children, true);
	    if (intersects.length > 0 && intersects[0].object.name === 'hotspot') {
	      root.Transition.start(intersects[0].object.hotspot_id);
	    }
	  };

	  on_mouse_move = function(event) {
	    var mouseSpeed;
	    if (root.Config.isUserInteracting === true) {
	      mouseSpeed = 0.3;
	      root.Config.target_lon = (onPointerDownPointerX - event.clientX) * mouseSpeed + onPointerDownLon;
	      root.Config.target_lat = (event.clientY - onPointerDownPointerY) * mouseSpeed + onPointerDownLat;
	    }
	  };

	  on_mouse_up = function(event) {
	    root.Config.isUserInteracting = false;
	    root.Config.stop_time = Date.now();
	    root.Config.autoplay = false;
	  };

	  on_mouse_wheel = function(event) {
	    var elementMouseIsOver, x, y;
	    x = event.pageX;
	    y = event.pageY;
	    elementMouseIsOver = document.elementFromPoint(x, y);
	    if ($("#" + elementMouseIsOver.id).parent().attr('id') !== 'panos-list') {
	      if (event.wheelDeltaY) {
	        root.camera.fov -= event.wheelDeltaY * 0.05;
	      } else if (event.wheelDelta) {
	        root.camera.fov -= event.wheelDelta * 0.05;
	      } else if (event.detail) {
	        root.camera.fov += event.detail * 1.0;
	      }
	      root.camera.fov = Math.max(60, Math.min(90, root.camera.fov));
	      root.camera.updateProjectionMatrix();
	    }
	  };

	  on_key_down = function(event) {
	    var container, keyPressed, near_id;
	    near_id = void 0;
	    if (!event) {
	      event = window.event;
	    }
	    root.Config.isUserInteracting = true;
	    keyPressed = event.keyCode;
	    if (keyPressed === 37) {
	      root.Config.current_lon = root.Config.lon;
	      root.Config.target_lon = root.Config.lon - 20;
	    } else if (keyPressed === 39) {
	      root.Config.current_lon = root.Config.lon;
	      root.Config.target_lon = root.Config.lon + 20;
	    } else if (keyPressed === 38) {
	      if (root.Transition.moving === false) {
	        near_id = root.Hotspot.front_nearest_hotspot(root.Transition.current_pano);
	        if (near_id !== -1) {
	          root.Transition.start(near_id);
	        }
	      }
	    } else if (keyPressed === 40) {
	      if (root.Transition.moving === false) {
	        near_id = root.Hotspot.back_nearest_hotspot(root.Transition.current_pano);
	        if (near_id !== -1) {
	          root.Transition.start(near_id);
	        }
	      }
	    } else if (keyPressed === 27) {
	      container = $("#" + DirectPano.pano_div_id);
	      if (container.width() === window.innerWidth && container.height() === window.innerHeight) {
	        root.escape_fullscreen();
	      }
	    }
	  };

	  on_key_up = function(event) {
	    root.Config.isUserInteracting = false;
	    root.Config.stop_time = Date.now();
	    root.Config.autoplay = false;
	  };

	  add_listeners = function() {
	    return $("#" + DirectPano.pano_div_id).on({
	      click: function(event) {
	        $("#" + DirectPano.pano_div_id).focus();
	      },
	      mousedown: function(event) {
	        on_mouse_down(event);
	      },
	      mousemove: function(event) {
	        on_mouse_move(event);
	      },
	      mouseup: function(event) {
	        on_mouse_up(event);
	      },
	      mousewheel: function(event) {
	        on_mouse_wheel(event.originalEvent);
	      },
	      DOMMouseScroll: function(event) {
	        on_mouse_wheel(event.originalEvent);
	      },
	      touchstart: function(event) {
	        touch_handler(event.originalEvent);
	      },
	      touchmove: function(event) {
	        touch_handler(event.originalEvent);
	      },
	      touchend: function(event) {
	        touch_handler(event.originalEvent);
	      },
	      keydown: function(event) {
	        on_key_down(event);
	      },
	      keyup: function(event) {
	        on_key_up(event);
	      }
	    });
	  };

	  remove_listeners = function() {
	    $("#" + DirectPano.pano_div_id).off();
	  };

	  root.add_listeners = add_listeners;

	  root.remove_listeners = remove_listeners;

	  module.exports = root;

	}).call(this);


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.3
	(function() {
	  var root, transition;

	  root = __webpack_require__(3);

	  transition = (function() {
	    function transition(pano, hotspot_angles) {
	      var path;
	      this.pano = pano;
	      this.current_pano = 0;
	      this.moving = false;
	      this.hotspot_angles = hotspot_angles;
	      this.destroy = false;
	      root.clear_images = {};
	      root.blur_images = {};
	      root.clear_images[this.current_pano] = [];
	      path = this.pano[this.current_pano][1];
	      this.blur_pano = new root.Pano(0, true);
	      this.clear_pano = new root.Pano(0, false);
	      this.blur_pano.create_pano(path, 0.0);
	      this.clear_pano.create_pano(path, 1.0).done(function() {
	        var time;
	        time = 1000;
	        return $("#start-image").fadeTo(time, 0, function() {
	          $("#start-image").remove();
	          root.Config.isUserInteracting = false;
	        });
	      });
	      this.preload_images();
	      return;
	    }

	    transition.prototype.save_clear_images = function() {
	      var current_pano, i, pano;
	      current_pano = this.current_pano;
	      pano = this.pano;
	      if (!root.clear_images[current_pano]) {
	        root.clear_images[current_pano] = [];
	        i = 0;
	        while (i < 6) {
	          (function() {
	            var image_index, j, texture;
	            texture = new THREE.Texture(root.texture_placeholder);
	            image_index = i;
	            root.clear_images[current_pano][image_index] = {};
	            j = 0;
	            while (j < 4) {
	              (function() {
	                var image, offset, path;
	                offset = j;
	                image = new Image();
	                image.onload = function() {
	                  image.onload = null;
	                  texture.image = this;
	                  texture.needsUpdate = true;
	                  root.clear_images[current_pano][image_index][offset] = image;
	                };
	                path = pano[current_pano][1];
	                path = path.replace("%s", root.Config.img_name[i]);
	                path = path.replace("%v", j % 2);
	                path = path.replace("%h", parseInt(j / 2));
	                image.src = path;
	              })();
	              j++;
	            }
	          })();
	          i++;
	        }
	      }
	    };

	    transition.prototype.preload_images = function() {
	      var current_pano, hotspot_angles, i, pano;
	      i = 0;
	      current_pano = this.current_pano;
	      hotspot_angles = this.hotspot_angles;
	      pano = this.pano;
	      while (i < hotspot_angles[current_pano].length) {
	        (function() {
	          var j, pano_id;
	          pano_id = hotspot_angles[current_pano][i][0];
	          if (!root.blur_images[pano_id]) {
	            root.blur_images[pano_id] = [];
	            j = 0;
	            while (j < 6) {
	              (function() {
	                var image_index, k, texture;
	                texture = new THREE.Texture(root.texture_placeholder);
	                image_index = j;
	                root.blur_images[pano_id][image_index] = {};
	                k = 0;
	                while (k < 4) {
	                  (function() {
	                    var fpath, image, offset;
	                    offset = k;
	                    image = new Image();
	                    image.onload = function() {
	                      image.onload = null;
	                      texture.image = this;
	                      texture.needsUpdate = true;
	                      root.blur_images[pano_id][image_index][offset] = image;
	                    };
	                    fpath = pano[pano_id][1];
	                    fpath = fpath.replace(/%s/g, "../blur_" + (pano_id + 1) + "/" + root.Config.img_name[j]);
	                    fpath = fpath.replace(/%v/g, offset % 2);
	                    fpath = fpath.replace(/%h/g, parseInt(offset / 2));
	                    image.src = fpath;
	                  })();
	                  k++;
	                }
	              })();
	              j++;
	            }
	          }
	        })();
	        i++;
	      }
	    };

	    transition.prototype.preload_panel_images = function() {
	      var i, j, pano, pano_id;
	      i = 0;
	      pano = this.pano;
	      while (i < pano.length) {
	        if (pano[i][2] === true) {
	          pano_id = i;
	          if (!root.blur_images[pano_id]) {
	            root.blur_images[pano_id] = [];
	            j = 0;
	            while (j < 6) {
	              (function() {
	                var image_index, k, texture;
	                texture = new THREE.Texture(root.texture_placeholder);
	                image_index = j;
	                root.blur_images[pano_id][image_index] = {};
	                k = 0;
	                while (k < 4) {
	                  (function() {
	                    var fpath, image, offset;
	                    offset = k;
	                    image = new Image();
	                    image.onload = function() {
	                      image.onload = null;
	                      texture.image = this;
	                      texture.needsUpdate = true;
	                      root.blur_images[pano_id][image_index][offset] = image;
	                    };
	                    fpath = pano[pano_id][1];
	                    fpath = fpath.replace(/%s/g, "../blur_" + (pano_id + 1) + "/" + root.Config.img_name[j]);
	                    fpath = fpath.replace(/%v/g, offset % 2);
	                    fpath = fpath.replace(/%h/g, parseInt(offset / 2));
	                    image.src = fpath;
	                  })();
	                  k++;
	                }
	              })();
	              j++;
	            }
	          }
	        }
	        i++;
	      }
	    };

	    transition.prototype.start = function(hotspot_id, panoId) {
	      var current_pano, dist, error, hotspot_angle, i, old_pano_to_blur_pano, pano_id, rotate_angle, title;
	      current_pano = this.current_pano;
	      pano_id = null;
	      error = 0;
	      hotspot_angle = 0;
	      rotate_angle = 0;
	      dist = 0;
	      if (hotspot_id !== null) {
	        pano_id = this.hotspot_angles[current_pano][hotspot_id][0];
	        hotspot_angle = this.hotspot_angles[current_pano][hotspot_id][1];
	        error = this.hotspot_angles[current_pano][hotspot_id][2];
	        dist = 60;
	      } else {
	        pano_id = panoId;
	        error = 0;
	      }
	      $('div[id^=panos-list-entry-]').removeClass('active');
	      title = this.pano[pano_id][0];
	      i = 0;
	      while (i < this.pano.length) {
	        if (this.pano[i][0] === title && this.pano[i][2] === true) {
	          $('#panos-list-entry-' + i).addClass('active');
	          break;
	        }
	        i++;
	      }
	      this.moving = true;
	      this.current_pano = pano_id;
	      this.save_clear_images();
	      if (hotspot_id !== null) {
	        rotate_angle = this.find_rotation_angle(hotspot_angle);
	      } else {
	        root.Config.lon = this.pano[pano_id][3];
	        root.Config.lat = 0;
	      }
	      root.Hotspot.remove_hotspots();
	      root.Annotation.remove_annotations();
	      old_pano_to_blur_pano = this.old_pano_to_blur_pano.bind(this);
	      this.preload_images();
	      this.load_blur_pano(error, hotspot_angle, dist).done(function() {
	        old_pano_to_blur_pano(error, hotspot_angle, rotate_angle, dist);
	      });
	    };

	    transition.prototype.find_rotation_angle = function(hotspot_angle) {
	      var rotate_angle;
	      console.log(hotspot_angle);
	      rotate_angle = hotspot_angle - root.Config.lon;
	      while (rotate_angle > 180) {
	        rotate_angle = rotate_angle - 360;
	      }
	      while (rotate_angle < -180) {
	        rotate_angle = rotate_angle + 360;
	      }
	      if (rotate_angle > 50) {
	        rotate_angle = (rotate_angle - 180) % 360;
	      } else if (rotate_angle < -50) {
	        rotate_angle = (rotate_angle + 180) % 360;
	      }
	      rotate_angle = rotate_angle + root.Config.lon;
	      return rotate_angle;
	    };

	    transition.prototype.load_blur_pano = function(error, hotspot_angle, dist) {
	      var dfrd, i, j, path;
	      if (this.destroy) {
	        return $.when().done(function() {}).promise();
	      }
	      dfrd = [];
	      i = 0;
	      while (i < 24) {
	        dfrd[i] = $.Deferred();
	        i++;
	      }
	      this.blur_pano.pano_id = this.current_pano;
	      i = 0;
	      while (i < 6) {
	        j = 0;
	        while (j < 4) {
	          path = this.pano[this.current_pano][1];
	          path = path.replace(/%s/g, "../blur_" + (this.current_pano + 1) + "/" + root.Config.img_name[i]);
	          path = path.replace(/%v/g, j % 2);
	          path = path.replace(/%h/g, parseInt(j / 2));
	          this.blur_pano.mesh.children[i].children[j].material.map.dispose();
	          this.blur_pano.mesh.children[i].children[j].material.map = this.blur_pano.get_texture(this.pano_id, path, dfrd[4 * i + j], i, j);
	          this.blur_pano.mesh.children[i].children[j].material.opacity = 0;
	          j++;
	        }
	        i++;
	      }
	      this.blur_pano.mesh.rotation.y = THREE.Math.degToRad(error);
	      this.blur_pano.mesh.position.x = dist * Math.cos(THREE.Math.degToRad(hotspot_angle));
	      this.blur_pano.mesh.position.z = dist * Math.sin(THREE.Math.degToRad(hotspot_angle));
	      return $.when.apply($, dfrd).done(function() {}).promise();
	    };

	    transition.prototype.load_clear_pano = function(error) {
	      var dfrd, i, j, path;
	      if (this.destroy) {
	        return $.when().done(function() {}).promise();
	      }
	      dfrd = [];
	      i = 0;
	      while (i < 24) {
	        dfrd[i] = $.Deferred();
	        i++;
	      }
	      this.clear_pano.pano_id = this.current_pano;
	      this.clear_pano.mesh.rotation.y = THREE.Math.degToRad(error);
	      i = 0;
	      while (i < 6) {
	        j = 0;
	        while (j < 4) {
	          path = this.pano[this.current_pano][1];
	          path = path.replace(/%s/g, root.Config.img_name[i]);
	          path = path.replace(/%v/g, j % 2);
	          path = path.replace(/%h/g, parseInt(j / 2));
	          this.clear_pano.mesh.children[i].children[j].material.map.dispose();
	          this.clear_pano.mesh.children[i].children[j].material.map = this.clear_pano.get_texture(this.pano_id, path, dfrd[4 * i + j], i, j);
	          this.clear_pano.mesh.children[i].children[j].material.opacity = 0;
	          j++;
	        }
	        i++;
	      }
	      return $.when.apply($, dfrd).done(function() {}).promise();
	    };

	    transition.prototype.old_pano_to_blur_pano = function(error, hotspot_angle, rotate_angle, dist) {
	      var blur_pano, clear_pano, del, i, j, time, time1;
	      console.log(rotate_angle, root.Config.lon);
	      if (this.destroy) {
	        return;
	      }
	      time1 = 0.1;
	      if (dist) {
	        time1 = 0.4;
	        TweenLite.to(root.Config, time1, {
	          lon: rotate_angle,
	          lat: 0,
	          ease: Power0.easeOut
	        });
	      }
	      time = 1;
	      del = 0;
	      if (dist) {
	        time = 2;
	        del = 0.3;
	      }
	      blur_pano = this.blur_pano;
	      clear_pano = this.clear_pano;
	      TweenLite.to(blur_pano.mesh.position, time, {
	        x: 0,
	        z: 0,
	        delay: del,
	        ease: Expo.easeOut
	      });
	      i = 0;
	      while (i < 6) {
	        j = 0;
	        while (j < 4) {
	          TweenLite.to(clear_pano.mesh.children[i].children[j].material, time, {
	            opacity: 0,
	            delay: del,
	            ease: Expo.easeOut
	          });
	          TweenLite.to(blur_pano.mesh.children[i].children[j].material, time, {
	            opacity: 1,
	            delay: del,
	            ease: Expo.easeOut
	          });
	          j++;
	        }
	        i++;
	      }
	      TweenLite.to(clear_pano.mesh.position, time, {
	        x: -1 * dist * Math.cos(THREE.Math.degToRad(hotspot_angle)),
	        z: -1 * dist * Math.sin(THREE.Math.degToRad(hotspot_angle)),
	        delay: del,
	        ease: Expo.easeOut,
	        onComplete: this.check_new_pano_load.bind(this),
	        onCompleteParams: [error]
	      });
	    };

	    transition.prototype.check_new_pano_load = function(error) {
	      var blur_pano_to_new_pano, i, j;
	      if (this.destroy) {
	        return;
	      }
	      this.clear_pano.mesh.position.x = 0;
	      this.clear_pano.mesh.position.z = 0;
	      i = 0;
	      while (i < 6) {
	        j = 0;
	        while (j < 4) {
	          this.clear_pano.mesh.children[i].children[j].material.opacity = 0;
	          this.clear_pano.mesh.children[i].children[j].material.map.dispose();
	          this.blur_pano.mesh.children[i].children[j].material.opacity = 1;
	          j++;
	        }
	        i++;
	      }
	      blur_pano_to_new_pano = this.blur_pano_to_new_pano.bind(this);
	      this.load_clear_pano(error).done(function() {
	        blur_pano_to_new_pano(error);
	      });
	    };

	    transition.prototype.blur_pano_to_new_pano = function(error) {
	      var blur_pano, clear_pano, i, j, time;
	      if (this.destroy) {
	        return;
	      }
	      blur_pano = this.blur_pano;
	      clear_pano = this.clear_pano;
	      time = 0.5;
	      i = 0;
	      while (i < 6) {
	        j = 0;
	        while (j < 4) {
	          TweenLite.to(blur_pano.mesh.children[i].children[j].material, time, {
	            opacity: 0,
	            ease: Power0.easeOut
	          });
	          j++;
	        }
	        i++;
	      }
	      i = 0;
	      while (i < 6) {
	        j = 0;
	        while (j < 4) {
	          if (i === 5 && j === 3) {
	            TweenLite.to(clear_pano.mesh.children[i].children[j].material, time, {
	              opacity: 1,
	              ease: Power0.easeOut,
	              onComplete: this.complete.bind(this),
	              onCompleteParams: [error]
	            });
	          } else {
	            TweenLite.to(clear_pano.mesh.children[i].children[j].material, time, {
	              opacity: 1,
	              ease: Power0.easeOut
	            });
	          }
	          j++;
	        }
	        i++;
	      }
	    };

	    transition.prototype.alter_moving = function() {
	      return this.moving = false;
	    };

	    transition.prototype.complete = function(error) {
	      var alter_moving, pano_id;
	      if (this.destroy) {
	        return;
	      }
	      this.clear_pano.mesh.rotation.y = 0;
	      root.Config.lon += error;
	      pano_id = this.current_pano;
	      alter_moving = this.alter_moving.bind(this);
	      root.Hotspot.add_hotspots(pano_id).done(function() {
	        root.Annotation.add_annotations(pano_id);
	        alter_moving();
	      });
	    };

	    transition.prototype.destroy_transition = function() {
	      var blur_pano, clear_pano;
	      this.destroy = true;
	      blur_pano = this.blur_pano;
	      clear_pano = this.clear_pano;
	      TweenLite.killTweensOf(blur_pano);
	      TweenLite.killTweensOf(clear_pano);
	      this.blur_pano.destroy_pano();
	      this.clear_pano.destroy_pano();
	      this.blur_pano = null;
	      this.clear_pano = null;
	    };

	    return transition;

	  })();

	  root.transition = transition;

	  module.exports = root;

	}).call(this);


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.3
	(function() {
	  var annotation, object, root;

	  root = __webpack_require__(4);

	  object = void 0;

	  annotation = (function() {
	    function annotation(annotation_angles, content) {
	      this.annotation_angles = annotation_angles;
	      this.content = content;
	      this.panoid = void 0;
	      this.length = 0;
	      this.destroy = false;
	    }

	    annotation.prototype.add_annotation = function(annotation_id) {
	      var anno_id, div;
	      anno_id = annotation_id;
	      annotation_id = "annotation_" + annotation_id;
	      div = $("<div></div>", {
	        id: annotation_id
	      });
	      div.prepend("<img class='annotation' height='40px' width='40px' src='../test/images/info.png'></img> <div class='hotspot-title'> <div class='hotspot-text'>" + this.annotation_angles[this.panoid][anno_id][2] + "</div> </div> <div class='info-hotspot'>" + this.annotation_angles[this.panoid][anno_id][3] + "</div>");
	      $("#" + DirectPano.pano_div_id).append(div);
	      $("#" + annotation_id).bind('click touchstart', function() {
	        if ($("#" + annotation_id).find('.info-hotspot').css('visibility') === 'visible') {
	          $("#" + annotation_id).find('.info-hotspot').css('visibility', 'hidden');
	          $("#" + annotation_id).find('.hotspot-title').css('visibility', 'hidden');
	          $("#" + annotation_id).find('.hotspot-title').css('opacity', '0');
	          $("#" + annotation_id).find('.annotation').css('border-radius', '100px');
	        } else {
	          $("#" + annotation_id).find('.info-hotspot').css('visibility', 'visible');
	          $("#" + annotation_id).find('.hotspot-title').css('visibility', 'visible');
	          $("#" + annotation_id).find('.hotspot-title').css('opacity', '1');
	          $("#" + annotation_id).find('.hotspot-title').css('border-radius', '0px 10px 0px 0px');
	          $("#" + annotation_id).find('.annotation').css('border-radius', '10px 0px 0px 0px');
	        }
	      });
	      $("#" + annotation_id).hover((function() {
	        $("#" + annotation_id).find('.hotspot-title').css('visibility', 'visible');
	        $("#" + annotation_id).find('.hotspot-title').css('opacity', '1');
	        if ($("#" + annotation_id).find('.info-hotspot').css('visibility') === 'hidden') {
	          $("#" + annotation_id).find('.hotspot-title').css('border-radius', '0px 10px 10px 0px');
	          $("#" + annotation_id).find('.annotation').css('border-radius', '10px 0px 0px 10px');
	        }
	      }), function() {
	        if ($("#" + annotation_id).find('.info-hotspot').css('visibility') === 'hidden') {
	          $("#" + annotation_id).find('.hotspot-title').css('visibility', 'hidden');
	          $("#" + annotation_id).find('.hotspot-title').css('opacity', '0');
	          $("#" + annotation_id).find('.annotation').css('border-radius', '100px');
	        }
	      });
	    };

	    annotation.prototype.add_annotations = function(panoid) {
	      var i;
	      this.panoid = panoid;
	      try {
	        this.length = this.annotation_angles[panoid].length;
	        i = 0;
	        while (i < this.length) {
	          if (this.destroy) {
	            this.remove_annotations();
	            return;
	          }
	          this.add_annotation(i);
	          i++;
	        }
	      } catch (_error) {
	        this.length = 0;
	        return;
	      }
	    };

	    annotation.prototype.remove_annotations = function() {
	      var i;
	      i = 0;
	      while (i < this.length) {
	        $("#annotation_" + i).remove();
	        i++;
	      }
	    };

	    annotation.prototype.destroy_annotation = function() {
	      this.destroy = true;
	      return this.remove_annotations();
	    };

	    annotation.prototype.update = function() {
	      var angle, annotation_id, container, i, panoid, pos, rad_angle, vector;
	      i = 0;
	      panoid = this.panoid;
	      while (i < this.length) {
	        annotation_id = "#annotation_" + i;
	        annotation = $(annotation_id);
	        angle = this.annotation_angles[panoid][i][0];
	        rad_angle = THREE.Math.degToRad(angle);
	        vector = new THREE.Vector3(30 * Math.cos(rad_angle), this.annotation_angles[this.panoid][i][1], 30 * Math.sin(rad_angle));
	        vector.x += 13 * Math.cos(rad_angle);
	        vector.z += 13 * Math.sin(rad_angle);
	        vector = vector.project(root.camera);
	        container = $("#" + DirectPano.pano_div_id);
	        pos = {
	          x: (vector.x + 1) / 2 * container.outerWidth(),
	          y: -(vector.y - 1) / 2 * container.outerHeight()
	        };
	        if (annotation) {
	          if (vector.x > 1 || vector.x < -1 || vector.y > 1 || vector.y < -1 || vector.z > 1 || vector.z < -1) {
	            if ($(annotation_id).css('display') !== 'none') {
	              $(annotation_id).removeAttr('style');
	              $(annotation_id).css('display', 'none');
	            }
	          } else {
	            $(annotation_id).css('display', 'inline');
	            $(annotation_id).css('left', '-10px');
	            $(annotation_id).css('top', '0px');
	            $(annotation_id).css('transform', 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0px)');
	            $(annotation_id).css('position', 'absolute');
	            $(annotation_id).css({
	              'font-family': "'Helvetica Neue', Helvetica, Arial, sans-serif"
	            });
	            $(annotation_id).css('font-size', '16px');
	          }
	        }
	        i++;
	      }
	    };

	    return annotation;

	  })();

	  root.annotation = annotation;

	  module.exports = root;

	}).call(this);


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.3
	(function() {
	  var hotspot, root;

	  root = __webpack_require__(5);

	  hotspot = (function() {
	    function hotspot(hotspot_angles) {
	      this.panoid = void 0;
	      this.hotspot_angles = hotspot_angles;
	      this.destroy = false;
	    }

	    hotspot.prototype.load_texture = function() {
	      var image, material, texture;
	      texture = new THREE.Texture(window.texture_placeholder);
	      material = new THREE.MeshBasicMaterial({
	        map: texture,
	        overdraw: 0,
	        side: THREE.DoubleSide,
	        depthTest: false,
	        depthWrite: true,
	        opacity: 1,
	        transparent: true
	      });
	      image = new Image();
	      image.onload = function() {
	        image.onload = null;
	        texture.image = this;
	        return texture.needsUpdate = true;
	      };
	      image.src = '../test/images/logo.png';
	      return material;
	    };

	    hotspot.prototype.add_hotspot = function(angle, dist, hotspotId, dfrd) {
	      var container, geometry, material, panoid, rad_angle, text, text_to_show, v;
	      geometry = new THREE.PlaneBufferGeometry(10, 10, 10);
	      material = this.load_texture();
	      hotspot = new THREE.Mesh(geometry, material);
	      rad_angle = THREE.Math.degToRad(angle);
	      hotspot.position.x = 60 * Math.cos(rad_angle);
	      hotspot.position.y = -50;
	      hotspot.position.z = 60 * Math.sin(rad_angle);
	      hotspot.renderOrder = 1;
	      v = new THREE.Vector3(-hotspot.position.x, 400, -hotspot.position.z);
	      hotspot.lookAt(v);
	      geometry = new THREE.PlaneBufferGeometry(1, 1, 1);
	      panoid = this.panoid;
	      text_to_show = "";
	      if (this.hotspot_angles[panoid][hotspotId][3] !== void 0) {
	        text_to_show = this.hotspot_angles[panoid][hotspotId][3];
	      }
	      hotspot.panoid = this.hotspot_angles[panoid][hotspotId][0];
	      hotspot.deg_angle = angle;
	      container = $("#" + DirectPano.pano_div_id);
	      text = $("<div></div>", {
	        id: "hotspot_" + this.hotspot_angles[panoid][hotspotId][0]
	      });
	      text.html(text_to_show);
	      $("#" + DirectPano.pano_div_id).append(text);
	      hotspot.hotspot_id = hotspotId;
	      hotspot.name = "hotspot";
	      root.scene.add(hotspot);
	      dfrd.resolve();
	    };

	    hotspot.prototype.add_hotspots = function(panoid) {
	      var dfrd, i, num_hotspots;
	      this.panoid = panoid;
	      num_hotspots = this.hotspot_angles[panoid].length;
	      dfrd = [];
	      i = 0;
	      while (i < num_hotspots) {
	        dfrd[i] = $.Deferred();
	        i++;
	      }
	      i = 0;
	      while (i < num_hotspots) {
	        if (this.destroy) {
	          this.remove_hotspots();
	          return;
	        }
	        this.add_hotspot(this.hotspot_angles[panoid][i][1], this.hotspot_angles[panoid][i][2], i, dfrd[i]);
	        i++;
	      }
	      return $.when.apply($, dfrd).done(function() {}).promise();
	    };

	    hotspot.prototype.remove_hotspots = function() {
	      var i, len, object, p;
	      len = root.scene.children.length;
	      p = 0;
	      i = 0;
	      while (i < len) {
	        object = root.scene.children[p];
	        if (object.name === "hotspot") {
	          object.geometry.dispose();
	          object.material.dispose();
	          root.scene.remove(object);
	          $("#hotspot_" + object.panoid).remove();
	        } else {
	          p += 1;
	        }
	        i++;
	      }
	    };

	    hotspot.prototype.front_nearest_hotspot = function(panoid) {
	      var flag, i, lon, near_angle, near_id, num_hotspots, temp;
	      num_hotspots = this.hotspot_angles[panoid].length;
	      near_id = -1;
	      near_angle = void 0;
	      flag = false;
	      i = 0;
	      while (i < num_hotspots) {
	        temp = this.hotspot_angles[panoid][i][1];
	        lon = (root.Config.lon + 360) % 360;
	        if (temp < 0) {
	          temp += 360;
	        }
	        if (((lon >= 45) && (lon <= 315) && (temp <= (lon + 45) % 360) && (temp >= (lon - 45 + 360) % 360)) || ((lon <= 45) && (temp >= 0) && (temp <= lon + 45)) || ((lon <= 45) && (temp >= (lon - 45 + 360) % 360) && (temp <= 360)) || ((lon >= 315) && (temp >= (lon - 45)) && (temp <= 360)) || ((lon >= 315) && (temp >= 0) && (temp <= (lon + 45) % 360))) {
	          if (flag === false || ((Math.abs(temp - lon)) < (Math.abs(near_angle - lon)))) {
	            near_angle = temp;
	            near_id = i;
	            flag = true;
	          }
	        }
	        i++;
	      }
	      return near_id;
	    };

	    hotspot.prototype.back_nearest_hotspot = function(panoid) {
	      var flag, i, lon, near_angle, near_id, num_hotspots, temp;
	      num_hotspots = this.hotspot_angles[panoid].length;
	      near_id = -1;
	      near_angle = void 0;
	      flag = false;
	      i = 0;
	      while (i < num_hotspots) {
	        temp = this.hotspot_angles[panoid][i][1];
	        lon = (root.Config.lon + 360 + 180) % 360;
	        if (temp < 0) {
	          temp += 360;
	        }
	        if (((lon >= 45) && (lon <= 315) && (temp <= (lon + 45) % 360) && (temp >= (lon - 45 + 360) % 360)) || ((lon <= 45) && (temp >= 0) && (temp <= lon + 45)) || ((lon <= 45) && (temp >= (lon - 45 + 360) % 360) && (temp <= 360)) || ((lon >= 315) && (temp >= (lon - 45)) && (temp <= 360)) || ((lon >= 315) && (temp >= 0) && (temp <= (lon + 45) % 360))) {
	          if (flag === false || ((Math.abs(temp - lon)) < (Math.abs(near_angle - lon)))) {
	            near_angle = temp;
	            near_id = i;
	            flag = true;
	          }
	        }
	        i++;
	      }
	      return near_id;
	    };

	    hotspot.prototype.destroy_hotspot = function() {
	      this.destroy = true;
	      return this.remove_hotspots();
	    };

	    hotspot.prototype.update = function() {
	      var container, i, len, object, pos, rad_angle, text, vector;
	      len = root.scene.children.length;
	      i = 0;
	      while (i < len) {
	        object = root.scene.children[i];
	        if (object.name === "hotspot") {
	          text = $("#hotspot_" + object.panoid);
	          vector = object.position.clone();
	          rad_angle = THREE.Math.degToRad(object.deg_angle + 5);
	          vector.x += 13 * Math.cos(rad_angle);
	          vector.z += 13 * Math.sin(rad_angle);
	          vector = vector.project(root.camera);
	          container = $("#" + DirectPano.pano_div_id);
	          pos = {
	            x: (vector.x + 1) / 2 * container.outerWidth(),
	            y: -(vector.y - 1) / 2 * container.outerHeight()
	          };
	          if (text) {
	            if (vector.x > 1 || vector.x < -1 || vector.y > 1 || vector.y < -1 || vector.z > 1 || vector.z < -1) {
	              if ($("#hotspot_" + object.panoid).css('display') !== 'none') {
	                $("#hotspot_" + object.panoid).removeAttr('style');
	                $("#hotspot_" + object.panoid).css({
	                  'display': 'none'
	                });
	              }
	            } else {
	              $("#hotspot_" + object.panoid).css({
	                'display': 'block',
	                'left': '-10px',
	                'top': '0px',
	                'transform': 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0px)',
	                'text-align': 'left',
	                'color': 'Yellow',
	                'position': 'absolute',
	                'margin-left': '-20px'
	              });
	            }
	          }
	        }
	        i++;
	      }
	    };

	    return hotspot;

	  })();

	  root.hotspot = hotspot;

	  module.exports = root;

	}).call(this);


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.3
	(function() {
	  var Pano, dist, offset, root, sides;

	  root = __webpack_require__(6);

	  offset = [
	    {
	      position: [-150 / 2, 150 / 2, 0]
	    }, {
	      position: [150 / 2, 150 / 2, 0]
	    }, {
	      position: [-150 / 2, -150 / 2, 0]
	    }, {
	      position: [150 / 2, -150 / 2, 0]
	    }
	  ];

	  dist = 150;

	  sides = [
	    {
	      position: [-1 * dist, 0, 0],
	      rotation: [0, Math.PI / 2, 0]
	    }, {
	      position: [dist, 0, 0],
	      rotation: [0, -Math.PI / 2, 0]
	    }, {
	      position: [0, dist, 0],
	      rotation: [Math.PI / 2, 0, Math.PI]
	    }, {
	      position: [0, -1 * dist, 0],
	      rotation: [-Math.PI / 2, 0, Math.PI]
	    }, {
	      position: [0, 0, dist],
	      rotation: [0, Math.PI, 0]
	    }, {
	      position: [0, 0, -1 * dist],
	      rotation: [0, 0, 0]
	    }
	  ];

	  Pano = (function() {
	    function Pano(pano_id1, is_blur) {
	      this.pano_id = pano_id1;
	      this.is_blur = is_blur;
	      this.name = "panorama";
	      this.destroy = false;
	    }

	    Pano.prototype.create_pano = function(path1, opacity) {
	      var dfrd, geometry, i, j, material, path, slice, slices;
	      this.mesh = new THREE.Object3D();
	      dfrd = [];
	      i = 0;
	      while (i < 24) {
	        dfrd[i] = $.Deferred();
	        i++;
	      }
	      i = 0;
	      while (i < 6) {
	        j = 0;
	        slices = new THREE.Object3D();
	        root.clear_images[this.pano_id][i] = {};
	        while (j < 4) {
	          path = path1;
	          console.log(path);
	          path = path.replace(/%s/g, root.Config.img_name[i]);
	          path = path.replace(/%v/g, j % 2);
	          path = path.replace(/%h/g, parseInt(j / 2));
	          material = this.load_texture(path, i, j, dfrd[4 * i + j]);
	          geometry = root.Config.webgl ? new THREE.PlaneBufferGeometry(300 / 2, 300 / 2, 7, 7) : new THREE.PlaneGeometry(300 / 2, 300 / 2, 20, 20);
	          slice = new THREE.Mesh(geometry, material);
	          slice.material.transparent = true;
	          slice.material.opacity = opacity;
	          slice.position.x = offset[j].position[0];
	          slice.position.y = offset[j].position[1];
	          slice.position.z = offset[j].position[2];
	          slices.add(slice);
	          j++;
	        }
	        slices.rotation.x = sides[i].rotation[0];
	        slices.rotation.y = sides[i].rotation[1];
	        slices.rotation.z = sides[i].rotation[2];
	        slices.updateMatrix();
	        slices.position.x = sides[i].position[0];
	        slices.position.y = sides[i].position[1];
	        slices.position.z = sides[i].position[2];
	        slices.updateMatrix();
	        this.mesh.add(slices);
	        i++;
	      }
	      root.scene.add(this.mesh);
	      return $.when.apply($, dfrd).done(function() {}).promise();
	    };

	    Pano.prototype.destroy_pano = function() {
	      var i, j, results;
	      this.destroy = true;
	      root.scene.remove(this.mesh);
	      i = 0;
	      results = [];
	      while (i < 6) {
	        j = 0;
	        while (j < 4) {
	          this.mesh.children[i].children[j].material.map.dispose();
	          this.mesh.children[i].children[j].material.dispose();
	          this.mesh.children[i].children[j].geometry.dispose();
	          this.mesh.children[i].children[j] = null;
	          j++;
	        }
	        this.mesh.children[i] = null;
	        results.push(i++);
	      }
	      return results;
	    };

	    Pano.prototype.load_texture = function(path, image_index, offset, dfrd) {
	      var image, material, pano_id, texture;
	      texture = new THREE.Texture(root.texture_placeholder);
	      material = new THREE.MeshBasicMaterial({
	        map: texture,
	        overdraw: 0,
	        side: THREE.DoubleSide,
	        blending: THREE.AdditiveBlending,
	        depthTest: false
	      });
	      pano_id = this.pano_id;
	      image = new Image();
	      image.onload = function() {
	        image.onload = null;
	        texture.image = this;
	        texture.needsUpdate = true;
	        dfrd.resolve();
	        root.clear_images[pano_id][image_index][offset] = image;
	      };
	      image.src = path;
	      return material;
	    };

	    Pano.prototype.get_texture = function(panoid, path, dfrd, image_index, offset) {
	      var flag, image, texture;
	      flag = false;
	      texture = new THREE.Texture(root.texture_placeholder);
	      panoid = this.pano_id;
	      if (root.clear_images[panoid][image_index][offset]) {
	        flag = true;
	        texture.image = root.clear_images[panoid][image_index][offset];
	        texture.needsUpdate = true;
	        dfrd.resolve();
	        return texture;
	      }
	      if (this.is_blur === true && root.blur_images[panoid] && root.blur_images[panoid][image_index][offset]) {
	        flag = true;
	        texture.image = root.blur_images[panoid][image_index][offset];
	        texture.needsUpdate = true;
	        dfrd.resolve();
	        return texture;
	      }
	      image = new Image();
	      image.onload = function() {
	        texture.image = this;
	        texture.needsUpdate = true;
	        dfrd.resolve();
	      };
	      image.src = path;
	      return texture;
	    };

	    return Pano;

	  })();

	  root.Pano = Pano;

	  module.exports = root;

	}).call(this);


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.3
	(function() {
	  var animation, flag, lat, root, time;

	  root = __webpack_require__(7);

	  time = void 0;

	  lat = void 0;

	  flag = false;

	  animation = (function() {
	    function animation() {
	      this.destroy = false;
	      this.animate();
	    }

	    animation.prototype.animate = function() {
	      var duration;
	      if (!this.destroy) {
	        requestAnimationFrame(this.animate.bind(this));
	        this.update();
	        root.Hotspot.update();
	        root.Annotation.update();
	        if (root.Config.target_lon !== void 0 && root.Config.current_lon !== void 0 && Math.abs(root.Config.target_lon - root.Config.current_lon) > 0.1) {
	          if (root.Transition.moving === true) {
	            root.Config.target_lon === void 0;
	            root.Config.current_lon = void 0;
	          } else {
	            root.Config.current_lon = root.Config.current_lon + (root.Config.target_lon - root.Config.current_lon) * 0.15;
	            root.Config.lon = (root.Config.current_lon + 360) % 360;
	          }
	        }
	        if (root.Config.target_lat !== void 0 && root.Config.current_lat !== void 0 && Math.abs(root.Config.target_lat - root.Config.current_lat) > 0.1) {
	          if (root.Transition.moving === true) {
	            root.Config.target_lat = void 0;
	            root.Config.current_lat = void 0;
	          } else {
	            root.Config.current_lat = root.Config.current_lat + (root.Config.target_lat - root.Config.current_lat) * 0.15;
	            root.Config.lat = root.Config.current_lat;
	          }
	        }
	        if (flag === true) {
	          if (root.Config.isUserInteracting === true) {
	            flag = false;
	          } else {
	            duration = Date.now() - time;
	            if (duration < 1000) {
	              root.Config.lat = lat - (lat * duration / 1000);
	            } else {
	              flag = false;
	              root.Config.lat = 0;
	            }
	          }
	        }
	      }
	    };

	    animation.prototype.update = function() {
	      var duration, phi, theta;
	      if (root.Config.isUserInteracting === false && root.Config.autoplay === true && root.Transition.moving === false) {
	        root.Config.lon += 0.2;
	      } else if (root.Config.isUserInteracting === false) {
	        duration = Date.now() - root.Config.stop_time;
	        if (duration > 2000) {
	          root.Config.autoplay = true;
	          flag = true;
	          time = Date.now();
	          lat = root.Config.lat;
	        }
	      }
	      root.Config.lon = (root.Config.lon + 360) % 360;
	      root.Config.lat = Math.max(-35, Math.min(35, root.Config.lat));
	      phi = THREE.Math.degToRad(90 - root.Config.lat);
	      theta = THREE.Math.degToRad(root.Config.lon);
	      root.camera.target.x = 500 * Math.sin(phi) * Math.cos(theta);
	      root.camera.target.y = 500 * Math.cos(phi);
	      root.camera.target.z = 500 * Math.sin(phi) * Math.sin(theta);
	      root.camera.lookAt(root.camera.target);
	      root.renderer.render(root.scene, root.camera);
	    };

	    return animation;

	  })();

	  root.animation = animation;

	  module.exports = root;

	}).call(this);


/***/ },
/* 7 */
/***/ function(module, exports) {

	// Generated by CoffeeScript 1.9.3
	(function() {
	  var Config, active, blur_images, camera, clear_images, destroy, detect_webgl, escape_fullscreen, go_fullscreen, init, is_fullscreen, raycaster, renderer, root, scene, texture_placeholder;

	  root = {};

	  camera = void 0;

	  scene = void 0;

	  renderer = void 0;

	  texture_placeholder = void 0;

	  raycaster = new THREE.Raycaster;

	  blur_images = {};

	  clear_images = {};

	  active = void 0;

	  is_fullscreen = false;

	  Config = {
	    img_name: ['mobile_r', 'mobile_l', 'mobile_u', 'mobile_d', 'mobile_f', 'mobile_b'],
	    isUserInteracting: false,
	    lon: 0,
	    lat: 0,
	    stop_time: void 0,
	    autoplay: true,
	    webgl: true,
	    current_lon: void 0,
	    target_lon: void 0,
	    current_lat: void 0,
	    target_lat: void 0
	  };

	  go_fullscreen = function() {
	    var container, image;
	    container = $("#" + DirectPano.pano_div_id);
	    container.width(window.innerWidth + 'px').height(window.innerHeight + 'px');
	    renderer.setSize(container.outerWidth(), container.outerHeight());
	    image = $("#" + DirectPano.image_div_id);
	    image.css({
	      'visibility': 'hidden'
	    });
	    $("#panos-list").css('max-height', Math.min(400, window.innerHeight) + 'px');
	    camera.aspect = container.outerWidth() / container.outerHeight();
	    camera.updateProjectionMatrix();
	    is_fullscreen = true;
	  };

	  escape_fullscreen = function() {
	    var container, image;
	    container = $("#" + DirectPano.pano_div_id);
	    container.width(DirectPano.initial_width + 'px').height(DirectPano.initial_height + 'px');
	    renderer.setSize(container.outerWidth(), container.outerHeight());
	    image = $("#" + DirectPano.image_div_id);
	    image.css({
	      'visibility': 'visible'
	    });
	    $("#panos-list").css('max-height', Math.min(400, DirectPano.initial_height) + 'px');
	    camera.aspect = container.outerWidth() / container.outerHeight();
	    camera.updateProjectionMatrix();
	    is_fullscreen = false;
	  };

	  detect_webgl = function() {
	    var canvas, e;
	    try {
	      canvas = $('<canvas/>');
	      return !!(window.WebGLRenderingContext && (canvas[0].getContext('webgl') || canvas[0].getContext('experimental-webgl')));
	    } catch (_error) {
	      e = _error;
	      Config.webgl = false;
	      return false;
	    }
	  };

	  init = function() {
	    var container;
	    container = $("#" + DirectPano.pano_div_id);
	    container.width(Math.min(DirectPano.initial_width, window.innerWidth) + 'px').height(Math.min(DirectPano.initial_height, window.innerHeight) + 'px');
	    $("#panos-list").css('max-height', Math.min(400, DirectPano.initial_height) + 'px');
	    scene = new THREE.Scene;
	    texture_placeholder = $('<canvas/>').width(128).height(128);
	    renderer = detect_webgl() ? new THREE.WebGLRenderer : new THREE.CanvasRenderer;
	    renderer.setPixelRatio(window.devicePixelRatio);
	    container.append(renderer.domElement);
	    renderer.setSize(container.outerWidth(), container.outerHeight());
	    camera = new THREE.PerspectiveCamera(65, container.outerWidth() / container.outerHeight(), 1, 1100);
	    camera.target = new THREE.Vector3(0, 0, 0);
	    $('#' + DirectPano.image_div_id).bind('touchstart click', function() {
	      go_fullscreen();
	    });
	  };

	  destroy = function(dfrd) {
	    var i, j, len, len1, prop;
	    root.Hotspot = void 0;
	    for (i = 0, len = clear_images.length; i < len; i++) {
	      prop = clear_images[i];
	      clear_images[prop] = null;
	    }
	    for (j = 0, len1 = blur_images.length; j < len1; j++) {
	      prop = blur_images[j];
	      blur_images[prop] = null;
	    }
	    clear_images = {};
	    blur_images = {};
	    Config.lon = 0;
	    Config.lat = 0;
	    Config.stop_time = void 0;
	    Config.autoplay = true;
	  };

	  $(window).resize(function() {
	    var container;
	    container = $("#" + DirectPano.pano_div_id);
	    if (is_fullscreen === false) {
	      $("#panos-list").css('max-height', Math.min(400, DirectPano.initial_height) + 'px');
	      container.width(Math.min(DirectPano.initial_width, window.innerWidth) + 'px').height(Math.min(DirectPano.initial_height, window.innerHeight) + 'px');
	    } else {
	      $("#panos-list").css('max-height', Math.min(400, window.innerHeight) + 'px');
	      container.width(window.innerWidth + 'px').height(window.innerHeight + 'px');
	    }
	    renderer.setSize(container.outerWidth(), container.outerHeight());
	    camera.aspect = container.outerWidth() / container.outerHeight();
	    camera.updateProjectionMatrix();
	  });

	  init();

	  root.destroy = destroy;

	  root.Config = Config;

	  root.camera = camera;

	  root.scene = scene;

	  root.renderer = renderer;

	  root.blur_images = blur_images;

	  root.clear_images = clear_images;

	  root.texture_placeholder = texture_placeholder;

	  root.raycaster = raycaster;

	  root.escape_fullscreen = escape_fullscreen;

	  module.exports = root;

	}).call(this);


/***/ }
/******/ ]);